# Модуль 2

## Введение

Компания "Облачные решения для бизнеса" занимается проектированием, развертыванием и миграцией IT-систем. 
Вы являетесь DevOps-инженером, который занимается настройкой вычислительной инфраструктуры с применением систем оркестрации.

Недавно, нефтедобывающая компания "Вечность пахнет нефтью" обратилась в вашу организацию, с запросом на инсталляцию их нового приложения для учета переработанных нефтепродуктов. 

Данное приложение должно должно отвечать современным требованиям по масштабированию и отказоустойчивости.
Для решения данной задачи облачным архитектором был разработан проект-документ, часть из которого была передана вам для выполнения работы.

Системные аминистраторы уже подключили всё "on-premise" оборудование, настроили виртуальные машины и предоставили вам сетевой доступ к ИТ инфраструктуре заказчика,
передав реквезиты для подключения:

**Linux VM:**
root : P@ssw0rd!

![Сетевая топология инфраструктуры, уровень 3](./Diagram-Black.png)

## Кластер Kubernetes
Разверните кластер Kubernetes, версии не ниже 1.25, при помощи kubespray, кластер должен состоять из:
> * 3 Мастер узла (control plane,etcd)
> * 3 Рабочих узла
> * В качестве балансировщика нагрузки настройте MetalLB, в параметрах укажите следующее адресного пространства 10.100.1.10-10.100.1.15
> * В качестве Ingress-контроллера воспользуйтесь Nginx, отключите у него механизм HSTS и принудительного перевода на HTTPS, настройте собственный сертификат. Выделите для контроллера адрес 10.100.1.10
> * Выберите Flannel / Calico в качестве CNI
> * Для развертывания кластера БД понадобится PersistentVolumes, для этого настройте NFS Provisioner, а в качестве NFS хранилища выберете k8s-master-1
> * NFS хранилище должно предоставлять доступ к директории /opt/share с ограничением по доступности в рамках адресного пространства ВМ кластера


## Приложение

Приложение для учета переработанных нефтепродуктов скомпилированно в исполняемое приложение для архитектуры x86_64.

Данная программа хранит информацию о своих вычислениях в MongoDB. 

Само приложение представляет из себя HTTP-API, через которое можно запрашивать и загружать информацию о переработанных нефтепродуктах.

Приложение должно находиться в качестве OCI образа на базе ОС Debian в развернутом GitLab и помещено в его реестр образов. Кластер может потребовать дополнительного конфигурирования для корректной работы с реестром по HTTP или с самоподписанным сертификатом без доверия в кластере.

Приложение находится по адресу: http://ds2023.hw-sw.ru/app

Приложение необходимо развернуть при помощи Deployment таким образом, чтобы оно:
> * Реализуйте масштабирование реплик через проверку занятой оперативной памяти: если среднее значения потребляемой памяти Pod превышает 100 мегабайт, то необходимо увеличить количество реплик. Минимальное количество реплик 3, максимальное количество реплик 6. 
> * Было ограничено по использованию оперативной памяти (не более 180 мегабайт)
> * Проверялось на жизнеспособность и работоспособность по доступным для этого маршрутам, каждая проверка должна выполняться раз в 5 секунд.
> * Развернуто в **отдельном пространстве имен oil-application**, как и все связанные с приложением сущности
> * Название Deployment - **oil-refinery-application**
> * Настройте RollingUpdate метод обновления версии контейнера, ни один контейнер в рамках удаления не может быть удален, добавлено не более 2
> * Переменные окружения должны настраиваться через **отдельный ConfigMap** с названием **oil-app-configmap**
> * Приложение должно быть доступно через **Nginx Ingress** по адресу - **OilRefineryApplication.competitor{номерконкурсанта}.local** (например OilRefineryApplication.competitor6.local) и обрабатывать запросы по HTTP и HTTPS


Приложение имеет следующие маршруты:
> * **/** - Выводит основную инофрмацию о приложении
> * **/statistics** - Выводит сводную информацию о загруженных нефтепродуктах
> * **/health** - путь для проверок жизнеспособность
> * **/readiness** - путь для проверки работоспособности, в случае работоспособности возвращает **код 200** с текстом _"im ok"_
> * **/petrol** - _Метод GET, ContentType: application/json, 
Тело в виде 
JSON `{ "transaction-id":"{ИДЕНТИФИКАТОР_ТРАНЗАКЦИИ}"}`_ - Возвращает данные о конкретной транзакции
> * **/petrol** - _Метод POST, ContentType: application/json, Тело в виде JSON `{
    "type": "{ТИП_МАТЕРИАЛА}",
    "quantity": "{КОЛИЧЕСТВО}"
>}`_ - Добавляет объект в систему


Приложение принимает следующие переменные окружения:

> * **APP_DB_NAME** - Название базы данных (Назовите ее **OilRefineryDB-{номерконкурсанта}**)
> * **APP_ADDRESS** - Адрес, за которым закрепляется Flask API
> * **APP_PORT** - Порт, на котором будет работать приложение
> * **APP_DB_CONNECTION_URL** - строка соединения с БД, принимает в себя строку следующего формата _"mongodb://user:pass@host/?retryWrites=true&w=majority"_



## NoSQL База данных

Приложение требует для корректной работы настроенный кластер MongoDB
> * Кластер должен быть развернут в пространстве имен **database**
> * Разверните три экземпляра MongoDB, они должны быть в одном ReplicaSet
> * Подключайте приложение через Service, в котором будут перечислены все адреса MongoDB
> * Учетная запись и ее пароль могут быть произвольные

## DevSecOps платформа GitLab

Для дальнейшего выстраивания CI/CD процесса понадобится набор различных сервисов, позволяющих имплементировать DevOps практики, для этого надо настроить GitLab со следующими параметрами:

> * Для его работы выделена отдельная виртуальная машина **k8s-ci-cd**
> * Сервис должен быть развернут **при помощи Docker Compose** и размещен в директории **/opt/gitlab**
> * Сервис должен быть доступен по адресу **gitlab.competitor{номерконкурсанта}.local**
> * Создайте учетную запись **OutsourceAdministrator** с паролем **P@ssw0rd!** и выдайте ей права администратора
> * Создайте группу **Kubernetes** для дальнейшего добавления в нее проекта, добавьте в него созданного администратора
> * Создайте публичный проект **SmellsLikeOil** и используйте его для хранения образа образа приложения
> * Сервис должен быть развернут **с реестром образов** по пути **registry.gitlab.competitor{номерконкурсанта}.local**
> * Настройте для платформы использование 2 экземпляров Runner для выполнения CI/CD задач
> * Защитите доступ к сервису при помощи SSL сертификата

Данный сервис понадобится вам в следующий раз, так что уделите внимание его работоспособности.

## Мониторинг
Настройте мониторинг кластера Kubernetes.
> * Выбор решения мониторинга остается за исполнителем. 
> * Сервис должен быть доступен через Nginx Ingress по адресу - **monitoring.competitor{номерконкурсанта}.local**
> * Создайте учетную запись **OutsourceAdministrator** с паролем **P@ssw0rd!** и выдайте ей права администратора
> * Настройте мониторинг **всех предоставленных виртуальных машин**
> * Настройте дашборд c названием VM Dashboard, в котором будет выводиться **нагрзка ЦПУ, занятое место в оперативной памяти и доступную память по пути "/"**
> * Мониторинг должен опрашивать **kubelet**
> * Настройте дашборд Kubelet Dashboard, который будет выводить информацию о количестве работающих в данный момент Pod и любой другой полезной информацией
> * Защитите доступ к сервису при помощи SSL сертификата

## Клиентская ВМ
В вашем распоряжении имеется ВМ, с которого администраторы будут получать доступ к приложению и настроенным сервисам, поэтому необходимо настроить ее таким образом, чтобы она выполняла следующие задачи:
> * Было настроено любое графическое окружение, например Xfce
> * Были добавлены все созданные TLS сертификаты, чтобы система корректно их определяла и разрешала доступ к инфраструктуре по защищенным протоколам
> * Добавлена коннфигурация kubectl и имелся доступ до кластера
> * Добавлены все DNS записи, создаваемые в рамках развертывания инфраструктуры, в /etc/hosts
